# 1. Durchschnittstemperatur pro Monat
ggplot(wetter_finnland_Monate, aes(x = Monat, y = Temperatur_Mittel)) +
geom_line(color = "tomato", size = 1.2) +
geom_point(color = "tomato", size = 2) +
labs(
title = 'Monatliche Durchschnittstemperatur in Finnland 2017',
x = 'Monat',
y = 'Temperatur (°C)'
) +
theme_minimal()
# 2. Gesamtniederschlag pro Monat
ggplot(wetter_finnland_Monate, aes(x = Monat, y = Niederschlag_Gesamt)) +
geom_col(fill = "steelblue") +
labs(
title = 'Gesamtniederschlag pro Monat in Finnland 2017',
x = 'Monat',
y = 'Niederschlag (mm)'
) +
theme_minimal()
# 3. Durchschnittliche Schneehöhe pro Monat
ggplot(wetter_finnland_Monate, aes(x = Monat, y = Schneehöhe_Mittel)) +
geom_col(fill = "lightblue") +
labs(
title = 'Durchschnittliche Schneehöhe pro Monat in Finnland 2017',
x = 'Monat',
y = 'Schneehöhe (cm)'
) +
theme_minimal()
# 4. Tage mit Schneedecke pro Monat
ggplot(wetter_finnland_Monate, aes(x = Monat, y = Tage_Schnee)) +
geom_col(fill = "darkblue") +
labs(
title = 'Anzahl der Tage mit Schneedecke pro Monat',
x = 'Monat',
y = 'Tage'
) +
theme_minimal()
# ----------------------------------------
# R Grundlagen und Datenstrukturen
# Autor: Janka Schultze
# Datum: 2025-06-26
# Beschreibung:
# Sammlung von Basisübungen zu Vektoren, Listen,
# Dataframes, Kontrollstrukturen und ggplot2-Visualisierungen.
# ----------------------------------------
# --- Listen in R ---
meine_liste <- list(
titel = 'Mein Experiment',
teilnehmer_ids = c(101, 102, 103),
ergebnis_matrix = matrix(1:4, nrow = 2),
ist_abgeschlossen = TRUE,
unterliste = list(a = 1, b = 2)
)
# Zugriff auf Elemente der Liste
meine_liste[[1]]      # Erstes Element (titel)
meine_liste[1:2]      # Erste zwei Elemente (titel + teilnehmer_ids)
# Element an Liste anhängen
meine_liste <- append(meine_liste, list(neues_element = 'Neuer Wert'))
print(meine_liste)
# --- Slicing von Vektoren und Listen ---
lst <- list(
v1 = 1:5,
v2 = c('a', 'b', 'c'),
v3 = c(TRUE, FALSE, TRUE)
)
print(lst[[1]])  # Ausgabe: 1 2 3 4 5
print(lst[[2]])  # Ausgabe: "a" "b" "c"
print(lst[3:length(lst)])  # Ausgabe: Logischer Vektor
# Wert ändern
lst[[1]][2] <- 99
print(lst)
# --- Kontrollstrukturen: for und while ---
# For-Schleife mit Zähler
for (i in 1:5) {
print(paste('Dies ist Durchlauf Nummer', i))
}
library(glue)
for (i in 1:5) {
print(glue('Dies ist Durchlauf Nummer {i}'))
}
# Iteration über Vektorwerte
vektor <- c(10, 20, 30, 40)
for (i in vektor) {
print(i)
}
# While-Schleife Beispiel
zaehler <- 1
while (zaehler <= 5) {
print(zaehler)
zaehler <- zaehler + 1
}
# Schleife mit break und next
for (i in vektor) {
if (i > 30) break
print(i)
}
for (i in 1:10) {
if (i %% 2 == 0) next
print(i)
}
# --- Funktionen: Definitionen, Rückgaben, Parameter ---
# Temperaturumrechnung (Celsius -> Fahrenheit)
celsius_zu_fahrenheit <- function(temp_c) {
temp_f <- temp_c * 9/5 + 32
return(temp_f)
}
temperatur_in_celsius <- 32
temperatur_in_fahrenheit <- celsius_zu_fahrenheit(temperatur_in_celsius)
print(paste(temperatur_in_celsius, 'Grad Celsius sind', temperatur_in_fahrenheit, 'Grad Fahrenheit.'))
# Gerade oder ungerade prüfen
ist_gerade <- function(x) {
if (x %% 2 == 0) {
return(TRUE)
} else {
return(FALSE)
}
}
print(ist_gerade(5))  # FALSE
print(ist_gerade(4))  # TRUE
#  Vektor-Zusammenfassung (optionale Ausgabe von Mittelwert / SD)
vektor_info <- function(v, zeige_mittelwert = TRUE, zeige_sd = TRUE) {
info <- c()
if (zeige_mittelwert) {
mw <- mean(v)
info <- c(info, paste('Mittelwert:', round(mw, 2)))
}
if (zeige_sd) {
sd_wert <- sd(v)
info <- c(info, paste('Standardabweichung:', round(sd_wert, 2)))
}
# Wenn nichts angezeigt werden soll, gib eine informative Meldung zurück
if (length(info) == 0) {
return('Keine Kennzahlen angefordert.')
}
return(paste(info, collapse = ' | '))
}
print(vektor_info(c(1, 2, 3, 4, 5)))
print(vektor_info(c(1, 2, 3, 4, 5), zeige_mittelwert = FALSE))
print(vektor_info(c(1, 2, 3, 4, 5), zeige_sd = FALSE))
print(vektor_info(c(1, 2, 3, 4, 5), zeige_mittelwert = FALSE, zeige_sd = FALSE))
# --- Statistik: einfache Implementationen ---
# Grundlegende statistische Kennzahlen
noten <- c(2.3, 1.0, 4.0, 5.0, 1.3, 2.7, 3.0, 1.7, 2.0, 4.0, 1.0, 3.3, 2.3)
print(mean(noten))
print(median(noten))
print(sd(noten))
print(min(noten))
print(max(noten))
# Eigene Mittelwertfunktion
mein_mittelwert <- function(v) {
mittelwert <- sum(v) / length(v)
return(mittelwert)
}
ergebnis_mittelwert <- mein_mittelwert(noten)
print(paste('Der Mittelwert des Vektors ist', round(ergebnis_mittelwert, 2)))
# Note bewerten (Funktion + Loop-Test)
note_bewerten <- function(note) {
if (note <= 1.3) {
return('Sehr gut bestanden')
} else if (note <= 4.0) {
return('Bestanden')
} else {
return('Durchgefallen')
}
}
test_noten <- c(1.0, 3.7, 5.0)
for (i in test_noten) {
bewertung <- note_bewerten(i)
print(paste0('Note ', i, ': ', bewertung))
}
# Note für Vektor ausgeben
for (i in noten) {
bewertung <- note_bewerten(i)
print(paste('Die Note', i, 'wird bewertet als:', bewertung))
}
# Statistik in einer Liste (korrekt aufgebaut)
Rohdaten <- noten
statistik_ergebnisse <- list(
Mittelwert = mean(Rohdaten),
Median = median(Rohdaten),
Standardabweichung = sd(Rohdaten),
Rohdaten = Rohdaten
)
print(statistik_ergebnisse)
print(statistik_ergebnisse$Median)
print(statistik_ergebnisse$Rohdaten)
# Analysefunktion, gibt Liste mit Kennzahlen zurück
deskriptive_analyse <- function(v) {
anzahl_bestanden <- sum(v <= 4.0)
anzahl_nicht_bestanden <- sum(v > 4.0)
info_liste <- list(
Anzahl_Noten = length(v),
Mittelwert_Noten = mean(v),
Median_Noten = median(v),
Standardabweichung_Noten = sd(v),
Pruefung_bestanden = anzahl_bestanden,
Pruefung_nicht_bestanden = anzahl_nicht_bestanden
)
return(info_liste)
}
analyse_ergebnis <- deskriptive_analyse(noten)
print(analyse_ergebnis)
# --- Dataframes: Erstellen, Selektieren, Manipulieren ---
# Dataframe erstellen & Basis-Inspektion
# 1. Beispiel:
studenten_df <- data.frame(
MatrikelNr = c(101, 102, 103, 104, 105, 106),
Name = c('Sophie', 'Lukas', 'Mia', 'Finn', 'Hannah', 'Leon'),
Studiengang = c('Informatik', 'BWL', 'Informatik', 'Medizin', 'BWL', 'Informatik'),
Semester = c(4, 2, 6, 8, 2, 4),
Note = c(1.7, 2.3, 1.3, 1.0, 2.7, 2.0),
stringsAsFactors = FALSE
)
str(studenten_df)
dim(studenten_df)
nrow(studenten_df)
ncol(studenten_df)
summary(studenten_df)
# Zugriff & Teil-Dataframe
print(studenten_df[['Studiengang']])
info_studenten <- studenten_df[, c('Name', 'Note')]
print(info_studenten)
# Alle Informatik-Studierenden
studenten_df[studenten_df$Studiengang == 'Informatik', ]
# Auswahl nach Bedingung (Boolean Indexing)
info_studenten[info_studenten$Note < 2.0, ]
# Neue logische Spalte hinzufügen / entfernen
studenten_df$Regelstudienzeit_ueberschritten <- studenten_df$Semester > 6
head(studenten_df)
# Spalte wieder entfernen (zurücksetzen)
studenten_df$Regelstudienzeit_ueberschritten <- NULL
head(studenten_df)
# 2.Beispiel:
namen <- c('Anna', 'Bernd', 'Carla', 'David', 'Eva')
alter <- c(28, 34, 29, 45, 31)
stadt <- c('Berlin', 'München', 'Hamburg', 'Berlin', 'Köln')
gehalt <- c(55000, 68000, 62000, 85000, 64000)
mitarbeiter_df <- data.frame(
Name = namen,
Alter = alter,
Stadt = stadt,
Gehalt = gehalt
)
print(mitarbeiter_df)
# Überblick über Struktur
str(mitarbeiter_df)
head(mitarbeiter_df)
tail(mitarbeiter_df)
dim(mitarbeiter_df)
names(mitarbeiter_df)
summary(mitarbeiter_df)
# Zugriff auf Zeilen und Spalten
mitarbeiter_df[1, 2]        # Zeile 1, Spalte 2
mitarbeiter_df[1]           # Spalte 1 als Dataframe
mitarbeiter_df[, 1]         # Spalte 1 als Vektor
mitarbeiter_df[2:length(mitarbeiter_df)] # Spalten 2 bis Ende
mitarbeiter_df$Gehalt       # Zugriff mit $
mitarbeiter_df['Name']      # Zugriff mit String
# Boolean indexing: Gehalt > 55000
print(mitarbeiter_df[mitarbeiter_df$Gehalt > 55000, ])
# Elemente ändern
mitarbeiter_df[[2,1]] <- 28
print(mitarbeiter_df[[2,1]])
# Auswahl mehrerer Zeilen/Spalten
print(mitarbeiter_df[1:2, 1:2])
print(mitarbeiter_df[c(2,3), c(1,4)])
# --- Dateioperationen: Formate lesen und schreiben ---
# Für Excel-Dateien verwenden wir die Pakete 'readxl' (lesen) und 'openxlsx' (schreiben)
# Installation (nur beim ersten Mal nötig):
# install.packages(c('readxl', 'openxlsx'), dependencies = TRUE)
library(readxl)
library(openxlsx)
# Hinweis: Für CSV-Dateien reichen Base R Funktionen (read.csv, write.csv).
# Alternativ bieten tidyverse-Pakete wie 'readr' modernere Möglichkeiten.
# Excel-Dateien: Beispiel mit Mitarbeiterdaten
mitarbeiter_daten <- read_excel('data/firma.xlsx', sheet = 'Mitarbeiter')
# Neue Spalte Eintrittsjahr hinzufügen
mitarbeiter_daten$Eintrittsjahr <- c(2020, 2021, 2019)
print(mitarbeiter_daten)
write.xlsx(mitarbeiter_daten, 'data/mitarbeiter_neu.xlsx', sheetName = 'Mitarbeiter')
# CSV-Dateien einlesen und anzeigen
meine_daten <- read.csv('data/verkaufsdaten.csv')
print(meine_daten)
str(meine_daten)
# CSV-Dateien speichern und erneut einlesen
export_daten <- data.frame(
ID = 1:3,
Produkte = c('Apfel', 'Birne', 'Orange'),
Preis = c(0.8, 1.2, 0.9)
)
# Speichern der Daten als CSV-Datei ohne Zeilennamen
write.csv(export_daten, 'data/export_daten.csv', row.names = FALSE)
# CSV mit deutschem Dezimal- und Trennzeichen einlesen
neu <- read.csv2('data/export_daten.csv', sep = ';', dec = '.')
print(neu)
# Beispiel: Liste von Datenframes für mehrere Tabellen in einer Excel-Datei
liste_von_daten <- list(
Produkte = export_daten,
Kunden = data.frame(KUNDENID = c(101, 102), Name = c('Müller', 'Schmidt'))
)
# Schreiben mehrerer Tabellen in eine Excel-Datei
write.xlsx(liste_von_daten, 'data/komplette_mappe.xlsx', sheetName = names(liste_von_daten))
# Excel-Datei einlesen zum Überprüfen
print(read_excel('data/komplette_mappe.xlsx'))
# Weitere CSV-Dateien mit Einstellungen lesen
auto_daten <- read.csv(
'data/autos.csv',
header = TRUE, sep = ",", dec = ".",
stringsAsFactors = FALSE, encoding = "UTF-8"
)
str(auto_daten)
print(auto_daten)
messwerte_daten <- read.csv(
'data/messwerte_de.csv',
header = TRUE, sep = ";", dec = ".",
stringsAsFactors = FALSE, encoding = "UTF-8"
)
str(messwerte_daten)
# Alternative: CSV mit deutschem Format lesen (Trennzeichen ; und Dezimal ,)
messwerte_daten_de <- read.csv2('data/messwerte_de.csv')
str(messwerte_daten_de)
print(messwerte_daten_de)
# Daten filtern und als CSV speichern
starke_autos <- subset(auto_daten, PS > 160)
write.csv(starke_autos, file = 'data/starke_autos.csv', row.names = FALSE)
# R-spezifische Formate speichern und laden
# Daten im RDS-Format speichern (binär)
saveRDS(auto_daten, file = 'data/auto_daten.rds')
# Daten aus dem Arbeitsspeicher entfernen
rm(auto_daten)
# Daten aus der RDS-Datei laden
auto_daten_geladen <- readRDS('data/auto_daten.rds')
str(auto_daten_geladen)
# --- Datenanalyse mit ggplot2 und linearem Modell ---
library(ggplot2)
data(diamonds, package = 'ggplot2')
# Lineares Modell: Preis erklärt durch Karat, Schliff, Klarheit
diamonds_lm <- lm(price ~ carat + cut + clarity, data = diamonds)
summary(diamonds_lm)
# Scatterplot mit Regressionslinie
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point(size = 1, color = "orange") +
geom_smooth(method = 'lm', se = FALSE, color = 'blue') +
labs(
title = 'Diamantenpreis in Abhängigkeit von Gewicht',
x = 'Gewicht (in carat)',
y = 'Diamantenpreis'
) +
theme_minimal()
# --- DPLYR (tidyverse): Filtern, Mutate, Arrange, Group_by ---
# Paket laden (tidyverse enthält dplyr, tidyr, ggplot2, etc.)
# Falls nicht installiert: install.packages("tidyverse")
library(dplyr)
# Beispiel-Daten für dplyr-Übungen
namen <- c('Anna', 'Bernd', 'Carla', 'David', 'Eva')
alter <- c(28, 34, 29, 45, 31)
stadt <- c('Berlin', 'München', 'Hamburg', 'Berlin', 'Köln')
gehalt <- c(55000, 68000, 62000, 85000, 64000)
vertriebler_df <- data.frame(
Name = namen,
Alter = alter,
Stadt = stadt,
Gehalt = gehalt,
stringsAsFactors = FALSE
)
# Filtern: älter als 30 und in München
vertriebler_df %>%
filter(Alter > 30, Stadt == 'München')
# Spalten auswählen
vertriebler_df %>% select(Name, Stadt)
# Neue Spalte berechnen (mutate)
vertriebler_df %>% mutate(Bonus = Gehalt * 0.05)
# Sortieren (aufsteigend / absteigend)
vertriebler_df %>% arrange(Alter)          # aufsteigend
vertriebler_df %>% arrange(desc(Alter))    # absteigend
# group_by + summarise Beispiel: Durchschnittsgehalt
vertriebler_df %>%
group_by(Stadt) %>%
summarise(Durchschnittsgehalt = mean(Gehalt))
# dplyr Aufgaben mit studenten_df
# select Name, Studiengang, Note
studenten_df %>% select(Name, Studiengang, Note)
# Filter BWL-Studenten im 2. Semester
studenten_df %>% filter(Studiengang == 'BWL', Semester == 2)
# Sortiere absteigend nach Note
studenten_df %>% arrange(desc(Note))
# Neue Spalte Note_in_Prozent
studenten_df %>%
mutate(Note_in_Prozent = (4 - Note) / 3 * 100)
# Durchschnittsnote pro Studiengang
durchschnitt_note_studiengang <- studenten_df %>%
group_by(Studiengang) %>%
summarise(Durchschnittsnote = mean(Note, na.rm = TRUE))
print(durchschnitt_note_studiengang)
# dplyr – Weitere Beispiele & häufige Fehler
# Kleines Demo-Dataframe
teilnehmer_df <- data.frame(
Name = c('Anna', 'Bernd', 'Clara', 'David', 'Eva'),
Alter = c(28, 34, 22, 45, 31),
Stadt = c('Berlin', 'München', 'Hamburg', 'Berlin', 'Köln'),
Punkte = c(85, 92, 78, 65, 95),
Immatrikuliert = c(TRUE, FALSE, TRUE, FALSE, TRUE),
stringsAsFactors = FALSE
)
# Auswahlmöglichkeiten
# Zwei Wege, Spalte Alter zu wählen
teilnehmer_df[, 'Alter']   # als data.frame-Spalte
teilnehmer_df$Alter        # als Vektor
# Neuer Dataframe mit Name & Stadt
teilnehmer_neu <- teilnehmer_df[, c('Name', 'Stadt')]
print(teilnehmer_neu)
# komplette 3. Zeile (Clara)
teilnehmer_df[3, ]
# erste und fünfte Zeile
teilnehmer_df[c(1, 5), ]
# Punktzahl von David
teilnehmer_df[4, 'Punkte']
# Personen älter als 30
teilnehmer_df[teilnehmer_df$Alter > 30, ]
# Personen aus Berlin
teilnehmer_df[teilnehmer_df$Stadt == 'Berlin', ]
# Name und Punkte von Immatrikulierten
teilnehmer_df[teilnehmer_df$Immatrikuliert == TRUE, c('Name', 'Punkte')]
# Slicing der ersten 2 Zeilen und ersten 3 Spalten
teilnehmer_df[1:2, 1:3]
# München oder Punkte < 80
teilnehmer_df[teilnehmer_df$Stadt == 'München' | teilnehmer_df$Punkte < 80, ]
# dplyr-Varianten (Pipe-Style)
# nicht in Berlin lebend
teilnehmer_df %>% filter(Stadt != 'Berlin')
# sortiert absteigend nach Punkte
teilnehmer_df %>% arrange(desc(Punkte))
# neue Spalte Alter_in_5_Jahren
teilnehmer_df %>% mutate(Alter_in_5_Jahren = Alter + 5)
# Immatrikulierte - Namen & Alter
teilnehmer_df %>%
filter(Immatrikuliert == TRUE) %>%
select(Name, Alter)
# Deskriptive Kennzahlen für das gesamte df
teilnehmer_df %>%
summarise(
Durchschnittsalter = mean(Alter),
Standardabweichung_Alter = sd(Alter),
Min_Punkte = min(Punkte)
)
# Durchschnittliche Punkte pro Stadt
ergebnis <- teilnehmer_df %>%
group_by(Stadt) %>%
summarise(Durchschnittliche_Punkte = mean(Punkte))
print(ergebnis)
# Anzahl Personen pro Stadt
teilnehmer_df %>% group_by(Stadt) %>% summarise(Anzahl = n())
# Fortgeschrittene Kette (Filtern, Status, Sortieren)
teilnehmer_df %>%
filter(Punkte > 70) %>%
mutate(Status = ifelse(Punkte > 90, 'Top Leistung', 'Gute Leistung')) %>%
arrange(Name)
# --- TIDYVERSE – Pivoting, Cleaning, Beispiele mit Datensätzen ---
library(tidyverse)
# Hinweis: einige Beispiel-Datensätze (relig_income, msleep, who) sind in Paketen enthalten.
# Falls ein Datensatz nicht vorhanden ist, gibt das Skript eine freundliche Meldung aus.
# ---- Beispiel: relig_income -> tidy (pivot_longer) ----
if (exists('relig_income')) {
tidy_relig_income <- relig_income %>%
pivot_longer(
cols = -religion,
names_to = 'einkommensklasse',
values_to = 'anzahl'
)
print(tidy_relig_income)
} else {
message('Datensatz "relig_income" nicht gefunden. Bitte Paket/Daten laden, wenn gewünscht.')
}
# ---- Beispiel: msleep -> pivot + group ----
if (exists('msleep')) {
pivot_table_sleep <- msleep %>%
filter(!is.na(vore)) %>%
group_by(order, vore) %>%
summarise(avg_sleep = mean(sleep_total, na.rm = TRUE)) %>%
ungroup()
# Beispiel, wie man ggf. pivot_wider verwendet (falls benötigt)
pivot_wide_sleep <- pivot_table_sleep %>%
pivot_wider(names_from = vore, values_from = avg_sleep, values_fill = 0)
print(pivot_table_sleep)
print(pivot_wide_sleep)
} else {
message('Datensatz "msleep" nicht gefunden. Bitte Paket/Daten laden, wenn gewünscht.')
}
# ---- Beispiel: WHO-Datensatz -> tidy ----
if (exists('who')) {
who_tidy <- who %>%
pivot_longer(
cols = starts_with('new_'),
names_to = 'schluessel',
values_to = 'anzahl'
) %>%
filter(!is.na(anzahl)) %>%
mutate(schluessel = str_replace(schluessel, 'newrel', 'new_rel')) %>%
separate(schluessel, into = c('neu', 'diagnose', 'geschlecht_alter'), sep = '_') %>%
select(-neu) %>%
separate(geschlecht_alter, into = c('geschlecht', 'altersgruppe'), sep = 1)
glimpse(who_tidy)
} else {
message('Datensatz "who" nicht gefunden. Bitte Paket/Daten laden, wenn gewünscht.')
}
# --- Praktische Tipps & Häufige Fehler: ---
# - Verwende immer '<-' für Zuweisungen (konsistenter Stil).
# - Achtung bei Faktorvergleichen: nur sinnvoll, wenn Faktor geordnet ist.
# - 'filter(Immatrikuliert = TRUE)' ist falsch: benutze '=='.
# - arrange(asc = Alter) ist falsch: benutze arrange(Alter) oder arrange(desc(Alter)).
# - Bei listen: keinesfalls '<-' innerhalb der list()-Konstruktion verwenden (Syntaxfehler).
# - Immer na.rm = TRUE setzen, wenn NA in Aggregationen vorkommen können.
